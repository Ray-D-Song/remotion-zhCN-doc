---
image: /generated/articles-docs-lambda-getrenderprogress.png
id: getrenderprogress
title: getRenderProgress()
slug: /lambda/getrenderprogress
crumb: 'Lambda API'
---

获取通过[`renderMediaOnLambda()`](/docs/lambda/rendermediaonlambda)触发的非[静态](https://www.remotion.dev/docs/lambda/renderstillonlambda)渲染的当前状态。

## 示例

```tsx twoslash
// @module: esnext
// @target: es2017

import {getRenderProgress} from '@remotion/lambda/client';

const progress = await getRenderProgress({
  renderId: 'd7nlc2y',
  bucketName: 'remotionlambda-d9mafgx',
  functionName: 'remotion-render-la8ffw',
  region: 'us-east-1',
});
```

:::note
最好从`@remotion/lambda/client`导入此函数，以避免在[无服务器函数](/docs/lambda/light-client)中出现问题。
:::

:::note
在渲染[静态](/docs/still)时不需要调用此函数。一旦您从[`renderStillOnLambda()`](/docs/lambda/renderstillonlambda)获取了[`renderId`](/docs/lambda/renderstillonlambda#renderid)，渲染应该已经完成了！
:::

## API

通过传递具有以下属性的对象来调用该函数：

### `renderId`

要获取其进度的渲染的唯一标识符。您可以从[`renderMediaOnLambda()`](/docs/lambda/rendermediaonlambda)的返回值中获取`renderId`。

### `bucketName`

保存有关渲染信息的存储桶。您可以从[`renderMediaOnLambda()`](/docs/lambda/rendermediaonlambda)的返回值中获取存储桶名称。

### `region`

Lambda函数所在的区域。

### `functionName`

触发渲染的函数的名称。

### `customCredentials?`<AvailableFrom v="3.2.23" />

如果要将渲染保存到[另一个云](/docs/lambda/custom-destination#saving-to-another-cloud)，请传递一个具有与您传递给[`renderMediaOnLambda()`](/docs/lambda/rendermediaonlambda#outname)或[`renderStillOnLambda()`](/docs/lambda/renderstillonlambda#outname)相同的`endpoint`、`accessKeyId`和`secretAccessKey`的对象。

### `forcePathStyle?`<AvailableFrom v="4.0.202" />

将`forcePathStyle`传递给AWS S3客户端。如果您不知道这是什么，您可能不需要它。


## 响应

返回一个解析为具有以下属性的对象的Promise：

### `overallProgress`

表示渲染的大致进度的介于0和1之间的数字。



### `chunks`

到目前为止已完全渲染的块数。



### `done`

如果视频已成功渲染并且所有过程已完成，则为`true`。否则为`false`。



### `encodingStatus`

如果尚未渲染所有块，则为`null`，否则为具有签名`{framesEncoded: number}`的对象，指示迄今为止在连接过程中已拼接多少帧。



### `renderId`

反映已传递为输入的`renderId`。



### `renderMetadata`

包含有关渲染的以下信息：

- `frameRange`：正在渲染的第一帧和最后一帧（使用`frameRange[1] - frameRange[0] + 1`获取已渲染的总帧数）。
- `startedDate`：渲染过程开始的时间戳。
- `totalChunks`：渲染分为多少部分。
- `estimatedTotalLambdaInvokations`：总共估计的Lambda函数调用次数，不包括对`getRenderProgress()`的调用。
- `estimatedRenderLambdaInvokations`：将渲染视频块的Lambda的估计数量。
- `compositionId`：正在渲染的合成的ID。
- `codec`：视频编码为的选定编解码器。



### `bucket`

渲染和其他工件保存在哪个存储桶中。



### `outputFile`

如果视频尚未渲染，则为`null`，如果视频完成渲染，则为包含指向最终工件的URL的`string`。



### `outKey`

如果视频尚未渲染，则为`null`，如果视频完成渲染，则为包含最终工件存储位置的S3密钥的`string`。



### `timeToFinish`

如果视频尚未渲染，则为`null`，描述渲染完成所需时间的`number`（以毫秒为单位）。



### `errors`

包含发生的错误的数组。



### `fatalErrorEncountered`

如果发生错误且视频无法渲染，则为`true`。您应停止轮询进度并检查`errors`数组。



### `currentTime`

Lambda函数响应进度请求的当前时间。

### `renderSize`

这个渲染结果已经节省了多少字节到 S3 存储桶中。

从 v4.0.165 开始，这可能会被轻微低估，因为 `progress.json` 文件没有被计算在内。

### `outputSizeInBytes`

从 v.3.3.9 开始可用。

输出产物的大小，以字节为单位。

### `lambdasInvoked`

已经被调用并开始渲染的 Lambdas 数量。

### `framesRendered`

从 v3.3.8 开始可用。

到目前为止已经渲染了多少帧，近似为可被 5 整除的数字。

### `costs`

描述到目前为止渲染成本的对象。如果渲染尚未完成，成本可能会增加。仅估算 AWS Lambda 的成本，不包括 S3 存储。这是一个尽力估算，但没有任何保证。该对象具有以下属性：

- `accruedSoFar`：成本，浮点数。
- `currency`：成本的货币。
- `displayCost`：格式化为字符串的成本。
- `disclaimer`：消除任何疑虑的文本免责声明。

### `estimatedBillingDurationInMilliseconds`<AvailableFrom v="4.0.74"/>

所有调用的 Lambda 函数的估计总运行时间，以毫秒为单位。随着渲染的进行，这个数字会增加。

### `mostExpensiveFrameRanges`

如果渲染正在进行中，则为 `null`。如果渲染已完成，则为一个包含以下结构的 5 个最昂贵块的数组：

- `chunk`：块的索引（从 0 开始）
- `timeInMilliseconds`：渲染该块所花费的时间
- `frameRange`：包含渲染该块的第一帧和最后一帧的元组。

### `artifacts`<AvailableFrom v="4.0.176"/>

在渲染过程中到目前为止创建的工件。[点击这里查看处理字段的示例。](/docs/artifacts#using-rendermedia-renderstill-or-renderframes)

## 参见

- [此函数的源代码](https://github.com/remotion-dev/remotion/blob/main/packages/lambda/src/api/get-render-progress.ts)
- [renderMediaOnLambda()](/docs/lambda/rendermediaonlambda)

Please paste the Markdown content you'd like me to translate into Chinese.
